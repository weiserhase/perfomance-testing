import os
import subprocess
import sys
import time
from collections import defaultdict
from collections.abc import Iterable
from typing import Any, Callable, Generic, TypeVar

from perf_tester.cli import compile_c_files_in_current_directory
from perf_tester.statistics import StatsCollection
from perf_tester.utils.progress_bar import ProgressBar

A = TypeVar("A")
T = TypeVar("T")


class CPerformanceTester(Generic[A]):
    """Compares the performance of one or more compiled C programs.
    Each registered program is executed with arguments generated by a transformation function.
    The execution times are recorded in a StatsCollection and printed using the table printer.

    The interface is kept similar to the original PerformanceTester.
    """

    def __init__(self, num_tests: int, gen_data: Callable[[], A], dir):
        self.num_tests = num_tests
        self.programs: list[tuple[str, str, Callable[[A], T]]] = []
        self.generate_data: Callable[[], A] = gen_data
        self.results: dict[str, list[float]] = defaultdict(list)
        self.stats_collection = StatsCollection()
        self.dir = dir
        
    def prompt_description(self):
        return

    # def store 

    def add_program(
        self, name: str, program_path: str, data_func: Callable[[A], T]
    ) -> None:
        """Add a compiled C program to test with its name, the executable path,
        and a data preparation function.

        The data preparation function converts the general data into a form (e.g. a list of command-line arguments)
        that the C program can use.
        """
        if not name:
            name = program_path
        self.programs.append((name, program_path, data_func))

    def run_tests(self) -> None:
        prog_bar = ProgressBar(self.num_tests)
        compile_c_files_in_current_directory()
        for i in range(self.num_tests):
            prog_bar.update(i)
            data = self.generate_data()
            for name, program_path, data_func in self.programs:
                args = data_func(data)
                command = [program_path] + list(args)
                start_time = time.perf_counter()
                completed = subprocess.run(
                    command,
                    capture_output=True,
                    shell=True,
                    cwd=self.dir,
                    text=True,
                )
                print(completed.stdout.format())
                if completed.stderr:
                    raise Exception(completed.stderr) 
                end_time = time.perf_counter()
                self.results[name].append(end_time - start_time)

    @staticmethod
    def run_test_mp(
        func: Callable[[T], Any], data_func: Callable[[A], T], data_block: list[A]
    ) -> list[float]:
        return []

    def compare_performance(self) -> None:
        """Runs the tests and prints the performance statistics using the StatsCollection."""
        self.run_tests()

        for name, res in self.results.items():
            self.stats_collection.add_stats(name, res)

        self.stats_collection.print_all_stats()
